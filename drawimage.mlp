type ratiopts =
   | ScaleX        (* scale x coords, but keep original Ratio *)
   | ScaleY        (* scale y coords, but keep original Ratio *)
   | Original      (* respect original size                   *)
   | FreeScale     (* scale to fit requested area             *)
;;

ifdef HAVE_CAMLIMAGES then

module M = struct
  open Image
  open Color
  open GraphicsY11
  
  let cache_prefix= "cache";;
  let cache_key = "advicache";;

  let verbose_image_access = Misc.option_flag false
      "--verbose_image_access"
      "\tChange the cursor while image loadings";;
  
  let images_camlimages = Hashtbl.create 107;;
  let images_graphics = Hashtbl.create 107;;

  let after f g = try let x = f () in  g (); x with e -> g (); raise e;;

  let cache_path file whitetransp psbbox ratiopt (w,h) =
    let file' = Userfile.fullpath (Unix.getcwd ()) file in
    let file' = if file == file' then String.copy file' else file' in
    for i = 0 to String.length file' - 1 do
      if file'.[i] = '/' then file'.[i] <- '-'
    done;
    let geom_string x = 
      if x >= 0 then "+" ^ string_of_int x else string_of_int x
    in
    let bbox_str =
      match psbbox with
      |	Some (llx,lly,urx,ury) -> 
	  Printf.sprintf "%s%s%s%s"
	    (geom_string llx) 
  	    (geom_string lly)
  	    (geom_string urx)
  	    (geom_string ury)
      |	None -> ""
    in
    let ratiopt_str = 
      match ratiopt with
      |	ScaleX -> "-x"
      |	ScaleY -> "-y"
      |	Original -> "-o"
      |	FreeScale -> ""
    in
    Filename.concat Userfile.cache_dir
      (Printf.sprintf "%s%s-%dx%d%s%s%s"
	 cache_prefix
  	 file'
  	 w h
	 bbox_str
	 ratiopt_str
  	 (if whitetransp then "-tr" else ""))
  ;;

  let cache_load file =
(*  prerr_endline ("cache_load " ^ file); *)
    let load ic =
      let s = String.create (String.length cache_key) in
      ignore (input ic s 0 (String.length cache_key));
      if s <> cache_key then 
	raise (Failure (file ^ " has no proper header"));
      let rgba = input_value ic in (* bool *)
      let width = input_value ic in
      let height = input_value ic in
      let data = input_value ic in
      rgba, width, height, data
    in
    let ic = open_in_bin file in
    after (fun () ->
      let rgba, width, height, data = load ic in
      if rgba then Rgba32 (Rgba32.create_with width height data) 
      else Rgb24 (Rgb24.create_with width height data))
      (fun () -> close_in ic)
  ;;

  let cache_save file img = 
(*  prerr_endline ("cache_save " ^ file); *)
    let save oc =
      output oc cache_key 0 (String.length cache_key);
      match img with
      | Rgba32 image ->
  	  output_value oc true;
  	  output_value oc image.Rgba32.width;
  	  output_value oc image.Rgba32.height;
(* prerr_endline (Printf.sprintf "(%dx%d) %d bytes written"
		 image.Rgba32.width image.Rgba32.height
		 (String.length (Bitmap.dump image.Rgba32.data))); *)
  	  output_value oc (Bitmap.dump image.Rgba32.data);
      | Rgb24 image ->
  	  output_value oc false;
  	  output_value oc image.Rgb24.width;
  	  output_value oc image.Rgb24.height;
  	  output_value oc (Bitmap.dump image.Rgb24.data);
      | _ -> assert false
    in
    let oc = open_out_bin file in
    after (fun () -> save oc) (fun () -> close_out oc) 
  ;;

  let clean_cache () =
    (* erase the files match with "cache-*" *)
    let prefix = cache_prefix in
    let suffix = "" in
    let dh = Unix.opendir Userfile.cache_dir in
    try while true do
      let file = Unix.readdir dh in
      if String.length file > 10 &&
  	 String.sub file 0 (String.length prefix) = prefix &&
  	 String.sub file (String.length file - String.length suffix)
  			 (String.length suffix) = suffix then begin
  			   Unix.unlink file
  			 end
    done with End_of_file -> 
      Unix.closedir dh
  ;;

  let image_load psbbox (w,h) file =
(*  prerr_endline ("image load " ^ file); *)
    try 
      match fst (Image.file_format file) with
      | Image.Ps ->
  	  let (llx,lly,urx,ury) =
	    match psbbox with
	    | Some bbox -> bbox
	    | None -> (0,0,w,h)
	  in
	  (* we need anti-aliasing *)
  	  let resx = float w /. (float (urx - llx) /. 72.0) *. 2.0
  	  and resy = float h /. (float (ury - lly) /. 72.0) *. 2.0 
  	  in
	  Ps.load_ps file (Some (llx,lly,urx,ury)) 
	    [Load_Resolution (resx,resy)]
      | _ ->
	  Image.load file []
    with
    | Failure s ->
        Misc.warning ("Failed to load " ^ file ^ ": " ^ s);
        raise Exit
    | Image.Wrong_file_type -> 
        Misc.warning ("Unsupported graphic format in: " ^ file);
        raise Exit
    | _ -> 
        Misc.warning ("Failed to load " ^ file);
        raise Exit
  ;;

  let resize_and_make_transparent image whitetransp ratiopt (w,h) = 
    let iw,ih = Image.size image in
    let w,h =
      match ratiopt with
      |	ScaleX -> w, Pervasives.truncate (float ih *. float w /. float iw)
      |	ScaleY -> Pervasives.truncate (float iw *. float h /. float ih), h
      |	Original -> iw, ih
      |	FreeScale -> w, h
    in
    let image' =
      match image with
      |	Index8 i -> Rgba32 (Index8.to_rgba32 i)
      |	Index16 i -> Rgba32 (Index16.to_rgba32 i)
      |	Rgb24 i -> image
      |	Rgba32 i -> image
      |	_ -> raise (Failure "color model is not supported")
    in
    let image'' =
      if whitetransp then begin
	match image' with
	| Rgb24 i ->
  	    let width = i.Rgb24.width 
  	    and height = i.Rgb24.height
  	    in
  	    let rgba = Rgba32.create width height in
  	    for y = 0 to height - 1 do
  	      for x = 0 to width - 1 do 
  		let rgb = Rgb24.unsafe_get i x y in
  		let a = 
  		  if whitetransp && rgb = {r=255;g=255;b=255} then 0
  		  else 255
  		in
  		Rgba32.unsafe_set rgba x y { color=rgb; alpha=a }
  	      done
  	    done;
  	    Rgba32 rgba
  	| Rgba32 i ->
  	    let width = i.Rgba32.width 
  	    and height = i.Rgba32.height
  	    in
  	    for y = 0 to height - 1 do
  	      for x = 0 to width - 1 do 
  		let rgba = Rgba32.unsafe_get i x y in
  		if rgba.color = {r=255;g=255;b=255} then 
  		  Rgba32.unsafe_set i x y { color=rgba.color; alpha=0 }
  	      done
  	    done;
  	    image
	| _ -> assert false
      end else image'
    in
    match image'' with
    | Rgb24 i -> Rgb24 (Rgb24.resize None i w h)
    | Rgba32 i -> Rgba32 (Rgba32.resize None i w h)
    | _ -> assert false
  ;;

  let load_and_resize file whitetransp psbbox ratiopt (w,h) =
    let file =
      Search.true_file_name [ "-format=" ^ Config.texpicts_kind ] file in
    let cache_name = cache_path file whitetransp psbbox ratiopt (w,h) in

    let image = 
      try
	try
	  Hashtbl.find images_camlimages cache_name
	with
	| Not_found ->
  	    if (Unix.stat file).Unix.st_mtime >= 
	      (Unix.stat cache_name).Unix.st_mtime
  	    then raise Exit;
	    (* Use the cache file *)
  	    if !verbose_image_access then 
	      GraphicsY11.set_cursor Cursor_exchange;
  	    let im = cache_load cache_name in
  	    if !verbose_image_access then 
	      GraphicsY11.set_cursor Cursor_left_ptr;
  	    im
      with _ ->
	if !verbose_image_access then GraphicsY11.set_cursor Cursor_exchange;
  	begin try Unix.unlink cache_name with _ -> () end;
  	let image = image_load psbbox (w,h) file in
	let image = resize_and_make_transparent image whitetransp ratiopt (w,h) in
	Userfile.prepare_file cache_name; 
  	(* we have no trivial image format for rgba32! *)
  	cache_save cache_name image;
  	if !verbose_image_access then GraphicsY11.set_cursor Cursor_left_ptr;
  	image
    in
    Hashtbl.replace images_camlimages cache_name image;
    cache_name, image
  ;;

  let draw_image image cache_name alpha blend (w,h) (x0, y0) =
    (* load_and_resize may not return exactly the same size 
       we specified as (w,h) *)
    let iw, ih = Image.size image in
    match image with
    | Rgb24 _ when alpha = 1.0 && blend = None -> 
        (* optimized *) 
  	let image_graphics =
  	  try Hashtbl.find images_graphics cache_name with
  	  | Not_found ->
  	      let im = Graphic_image.of_image image in
  	      Hashtbl.add images_graphics cache_name im;
  	      im
  	in
  	Graphics.draw_image image_graphics x0 y0
    | Rgb24 _ | Rgba32 _ ->
  	let alpha = truncate (alpha *. 255.0) in
  	let get_src_alpha =
  	  match image with
  	  | Rgb24 image -> fun x y -> Rgb24.unsafe_get image x y, alpha
  	  | Rgba32 image -> 
  	      fun x y ->
  		let {color= src; alpha= a} = Rgba32.unsafe_get image x y in
  		src, a * alpha / 255
  	  | _ -> assert false
  	in
  
  	let blend = 
  	  match blend with
  	  | Some b -> b
  	  | None -> fun dst src -> src
  	in
  
  	let org = Graphic_image.get_image x0 y0 w h in
  	let coloropt a =
  	  match a with
  	  | 0 -> fun dst src -> dst
  	  | 255 -> 
  	      fun dst src -> 
  		{r= blend dst.r src.r;
  		 g= blend dst.g src.g;
  		 b= blend dst.b src.b }
  	  | _ -> 
  	      let a' = 255 - a in
  	      fun dst src -> 
  		{r= (blend dst.r src.r * a + dst.r * a') / 255;
  		 g= (blend dst.g src.g * a + dst.g * a') / 255;
  		 b= (blend dst.b src.b * a + dst.b * a') / 255 }
  	in
  	for y = 0 to (min ih h) - 1 do
  	  for x = 0 to (min iw w) - 1 do
  	    let dst = Rgb24.unsafe_get org x y in
  	    let src, a = get_src_alpha x y in
  	    Rgb24.unsafe_set org x y (coloropt a dst src)
  	  done
  	done;
  	Graphic_image.draw_image (Rgb24 org) x0 y0
    | _ -> assert false
  ;;  


  let f file whitetransp alpha blend psbbox ratiopt (w,h) (x0,y0) =
    try
      let cache_name, image = 
	load_and_resize file whitetransp psbbox ratiopt (w,h) in
      (* load_and_resize may not return exactly the same size 
	 we specified as (w,h) *)
      draw_image image cache_name alpha blend (w,h) (x0,y0)
    with
    | Exit -> ()
    | Failure s -> Misc.warning s
    | e -> Misc.warning (Printexc.to_string e)
  ;;

end

else

module M = struct

  let f file whitetransp alpha blend psbbox ratiopt (w,h) (x0,y0) =
    (* just ignore the image. *)
    ()
  let clean_cache () = ()

end
;;

let f = M.f;;

let clean_cache = M.clean_cache;;
